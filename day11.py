# from matplotlib import pyplot# import numpy as np# import seaborn as sns# import matplotlib.pyplot as plt# import random# rolls = [ random.randrange(1,7) for i in range(500000)]# values, freq = np.unique(rolls, return_counts=True)# axes = sns.barplot(x=values, y=freq)   # Numpy# arr based programming# v.v high performance - n-dim arrays# 100 times# pandas built on numpy# series and dataframe# 'c' languageimport numpy as np# n1 = np.array([1,2,3,4,5,6])# #print(type(n1))# n2 = np.array([[2,3,4,5,7],[11,12,13]])# integers = np.array([[2,3,4,5,7],[11,12,13,14,15]])# print(integers)# floats = np.array([0.0,0.1,0.2])# #print(floats)# # google => scipy numpy data types# for row in integers:#     for col in row:#         print(col, end=' ')#     print()# print(np.zeros(5))# print(np.full((3,5),'x'))# print(np.arange(5))# print(np.arange(5,10))# print(np.arange(10,1,-2))# print(np.arange(0.0,1.0, 0.3))# print(np.arange(1,100001).reshape(4,25000))# print(np.arange(1,100001).reshape(100, 1000))# print(np.arange(2,41,2).reshape(4,5))# import random# %timeit rolls_list = [ random.randrange(1,7) for i in range(60000)]# 52.1 ms ± 538 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)# %timeit rolls_list_numpy = np.random.randint(1,7,60000)# 575 µs ± 2.82 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)# ipython magic timeit# hw: 1 - 10000000 find total compare perf regular list and numpy